
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>0x743</title>

<LINK REL="SHORTCUT ICON" HREF="/favicon.ico" type="image/x-icon">
<LINK REL="ICON"          HREF="/favicon.ico" type="image/x-icon">

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

<link rel="stylesheet" href="http://www.0x743.com/style.css" type="text/css">

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1688064-1";
urchinTracker();

		if (top.location!= self.location) {
			top.location = self.location.href
		}

</script>
<style>
#vee { overflow: auto; width: 100%; height: 2000px; border: dashed }
</style>

</head>
<body>

<table cellpadding="5" width=80% align=center>
<tr><td valign="top" width="100">
      <table WIDTH="145" BORDER="0" CELLSPACING="0" CELLPADDING="5">
        <tr> <td class="menuheading">Menu</td> </tr> <tr>
	  <td class="leftmenu" nowrap>
            ~~~~Main<br/>
            <a href=http://www.0x743.com>Home</a><br>
            <a href=http://www.0x743.com/contact.php>Contact</a><br/>

            <p/>~~~~Projects<br/>
            <a href=http://www.0x743.com/vee>vee</a><br/>
            <a href=http://www.patchlodge.com/x/computermeritbadge>Computer Merit Badge</a><br/>
            <a href=http://www.patchlodge.com>PatchLodge.com</a><br/>
            <a href=http://www.0x743.com/projects>Projects Summary</a><br/>

            <p/>~~~~My Bookmarks<br/>
            <a href=http://acm.lsu.edu/wiki/Resources>ACM@LSU CS Resources</a><br/>
            <a href=http://share.xmarks.com/folder/bookmarks/JVB1K4n8vD>Programming</a><br/>
            <a href=http://share.xmarks.com/folder/bookmarks/3FOmEcDzqY>Operating Systems</a><br/>
            <a href=http://share.xmarks.com/folder/bookmarks/jdvNK7PRGf>Computer Architecture</a><br/>
            <a href=http://share.xmarks.com/folder/bookmarks/Sz3sD6C2YU>Databases</a><br/>
            <br/>
          </td>
        </tr>
      </table>
</td>
<td valign="top" width="100%">

<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom" target="_top">
<table border="0">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="www.0x743.com"></input>
<label for="sbi" style="display: none">Enter your search terms</label>
<input type="text" name="q" size="31" maxlength="255" value="" id="sbi"></input>
<label for="sbb" style="display: none">Submit search form</label>
<input type="submit" name="sa" value="Search" id="sbb"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<table>
<tr>
<td>
<input type="radio" name="sitesearch" value="" id="ss0"></input>
<label for="ss0" title="Search the Web"><font size="-1" color="#000000">Web</font></label></td>
<td>
<input type="radio" name="sitesearch" value="www.0x743.com" checked id="ss1"></input>
<label for="ss1" title="Search www.0x743.com"><font size="-1" color="#000000">www.0x743.com</font></label></td>
</tr>
</table>
<input type="hidden" name="client" value="pub-2603268298460480"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="safe" value="active"></input>
<input type="hidden" name="cof" value="GALT:#0066CC;GL:1;DIV:#000000;VLC:336633;AH:center;BGC:FFFFFF;LBGC:ffffff;ALC:0066CC;LC:0066CC;T:000000;GFNT:666666;GIMP:666666;FORID:1"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
<!-- content -->
<pre>

Fri Oct 2 12:42:34 EDT 2009

The  Computer Merit Badge: how I'd complete the requirements NOW;
Part 3

--

This installment will not be as long or involved as the  previous
2, but it does built upon what I discussed in them

The second part of requirement #1 says, "Describe the major parts
of a computer system." And this is what I will do,  to  some  de-
gree.

Today,  mainstream  computers  are based upon what is called, the
"von Neumann" architecture.  This architecture was  one  proposed
by  a man named Jon von Neumann, who in his 50 years of life con-
tributed significantly to many scientific fields.  Computer  Sci-
ence was one of them, and his contributions to the field arguably
put computer technology (and the US) in a  position  to  advanced
significantly in the years to follow.

The  von  Neumann  architecture was proposed as a solution to the
problem of how to construct a device that physically realized the
theoretical  general  purpose computing model proposed by Turing.
This model is briefly discussed in the first installment of  this
series,  but  in short it provides the theoretical basis for con-
structing machines that are able to simulation other  "machines".
The  machines that a Turing Machine can simulate are realized to-
day as computer programs. The clear difference between the  theo-
retical  concept of a Turing Machine and what is physically real-
izable is, of course, the memory in a real machine can't be infi-
nite.  So, technically, any computer today (of von Neuman archec-
ture or not), is really what is known as a "linearly bounded  au-
tomata." But I digress.

So what does the von Neumann architecture consist of?  Well:

1. a processing unit (i.e., a CPU)

2. memory, providing random access for the reading and writing of
programs and raw data

3. facilities for input and output devices

Is this literally similar to the Turing Machine? No. A Turing Ma-
chine  actually consists of a tape (i.e., the memory + input) and
a  "read/write"  head  to  manipulate  the  tape.  However,   the
read/write  head  allows  for random access to memory (albeit not
necessarily direct). There are technically no input or output de-
vices  beyond the tape. The initial values of the tape and start-
ing position of the read/write head are all the TM  provides  for
input.  And  to make matters more complicated, the "input" of the
tape consists of data and program instructions encoded  together.
TMs  are very interesting devices, but I do not have the time nor
expertise to discuss them much here.

Now, back to the major parts of a computer system.   Modern  com-
puters are very complex, but the basic parts that make in them of
the von Neumann type are there.

1. a processor

2. RAM (i.e., random access memory)

3. Hard drive (i.e., a persistent instance of random access memo-
ry, a.k.a, "storage")

4. input (keyboard, mouse, cd-rom/dvd, etc)

5. output (monitor, printer, cd-rom/dvd, etc)

Are  there  other  types of architectures? The answer is YES, and
they are called collectively as, "non-von Neumann" architectures.
And while some of them are modeled off of the Turing Machine con-
cept, not all are.  For example, a man name Alonzo Church  (i.e.,
Turing's  PhD Advisor), created an equivalent but completely dif-
ferent may to investigate the questions of  "computability"  that
Turing  was  addressing with his models. Church's formulation has
come to be known as "Lamda Calculus," and is the basis for an ap-
proach  to  writing  programs called, "functional programming." I
will discuss this more when I discuss the requirement about  pro-
gramming.

Since  the  time  of  Turing, Church, and von Neumann, there have
been many conceptual models proposed that are  as  "powerful"  as
the  Turing  Machine.  Few, however, have provided the same basis
for building computational devices than von Neumann's. One inter-
esting  factoid  is that when one wishes to prove that their con-
ceptual model is as powerful as a TM (or "universal"), the  easi-
est  way  to prove this is to build a functioning TM out of their
concept.  This can be done, for example, using the set  of  rules
shown  to be universal which are called, "Conway's Game of Life."
(check out a little tool called Golly)

So what sets the von Neumann architecture apart from the  others,
including  machines that mimick the operation of a Turing Machine
(well, linearly bounded automata)? The  answer  goes  back  effi-
ciently accessing that vital ingredient required for computation-
al power by a device - MEMORY! The von  Neumann  architecture  is
conceptually meant to facilitate one thing - the efficient access
to memory.  Whereas in a TM, there is literally a single tape and
read/write head containing the input data, the program's instruc-
tions, and the "working" memory required for the execution of the
program;  the  von Neumann architecture provides direct (the key)
access to all of the memory, which is intuitively  how  we  think
about  the memory on our computers today. Another way to say this
is, the von Neumann architecture gives one  direct  access  to  a
running  program's "state," whereas other paradigms either do not
(in purely functional approaches) or in  a  very  convoluted  way
(e.g.,  a  "real"  TM or a TM built from cellular automata in the
GOL).

This way of thinking has also affected how most think about  pro-
gramming  and  programming languages.  Relatively few brave souls
engage in functional programming, as compared to those who engage
in  programming that is conceptually based on the von Neumann ar-
chitecture. While today, many traditional  programming  languages
are  incorporating  "functional"  features  that give some conve-
niences to the programmer, writing a program that is meant to  be
executed  in  a  top-to-bottom  way (i.e., procedurally) and that
stores values in "variables" relies on the view that the computer
executing  the  program  has direct access to the place in memory
where this variable is storing its data.  Since it is usually  of
no  concern where in memory the computer stores this information,
the programmer just assumes "on demand" access to  random  memory
locations. And this is why the most powerful access model of mem-
ory is called "random access."  At some point when you  take  the
time to learn more about the Turing Machine and the hoops a "pro-
gram" must jump through to store and retrieve the data written to
the  tape,  an  appreciation for the direct access to memory that
the von Neumann architecture will developed.  Not only  does  the
von  Neumann  architecture  actually  facilitate programming lan-
guages and methods that assume direct access to  memory  anywhere
and at anytime, but through these languages and methods it facil-
itates the kind of programatic thinking that most Humans are  in-
clined  to  learn the most easily.  Some would argue that the von
Neumann architecure and the langauges and programming methods  it
encourages are brutish and inelegant, but the simple fact is that
it has provide the world with a vast array of  technologies  that
might not have been practical otherwise.

Another characteristic of the von Neumann architecture that makes
it appealing, is that it is easy to  manufacture  computers  that
implement this kind of architecture. Consider that the very first
commercially successful computer that was designed to  be  easily
manufactured and "upgradable" was the IBM 360.  IBM pioneered the
standardization of parts and computer "families." And while  some
might argue that their motivation was purely to sell as many com-
puters as possible, the motivation of the engineers was  probably
just  as  strongly  driven  by  the  technical  challenge  of the
project. (I recommend reading Fred Brook's, "Mythical Man  Month"
for insights into the effort to produce the 360 series).

There  are  many  other reasons that the von Neumann architecture
persists, but it comes down to practicality - in design, manufac-
turing,  and use (including programming). In the installment that
I write  discussing  the  programming  requirements  of  the  Boy
Scout's  Computer  Merit Badge, I will discuss in more detail the
various approaches (or "paradigms") used by programming languages
and  software  developers - including more on "procedural" versus
"functional" programming,  where  "object  oriented"  programming
fits in, and will continue tying these issues back into the back-
ground I've provided here and in  the  other  sections  regarding
what a computer really is.

I will not be fulfilling the last part of requirement 1, which is
to list 4 uses of a computer. I believe one can do this on  one's
own.

The  next  installment  will  be discussing requirement #2, which
says:

Do the following:
   1. Tell what a program is and how it is developed.
   2. Give three examples of programming languages and what types
      of programming they are used for.
   3. Describe a source program and an object program.

Until then, take care.


--
Powered by <a href="http://www.0x743.com/vee">vee</a><br/>Copyright &copy; 2006-2011
<!-- content -->
</td>
<td valign="top">
      <table WIDTH="145" BORDER="0" CELLSPACING="0" CELLPADDING="5">
        <tr> <td class="menuheading">Links</td> </tr>
        <tr> 
          <td class="rightmenu">
            <!-- right top menu -->
            <a href="http://www.freebsd.org">FreeBSD</a></br/>
            <a href="http://www.perl.org">Perl</a></br/>
            <a href="http://www.qore.org">Qore</a>
          </td>
        </tr>
      </table>
</td>
</tr>
</table>

</td>
</tr>
</table>

</body>
</html>
