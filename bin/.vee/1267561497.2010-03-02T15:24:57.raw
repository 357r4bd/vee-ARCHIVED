Tue Mar 2 15:24:57 EST 2010

Backus vs Dijkstra - redux

--

In response my previous post:

'nf
<a href=/.vee/1265918013.2010-02-11T14:53:33.html>Backus vs Dijkstra</a>
'fi

I shall say only a few comments, otherwise I might go into an uninformed rant about functional programming (i.e., prematurely).

I suspect that Dijkstra was not as smitten with functional languages and programming as Backus was towards the end of his days [1]. But, [2] was mostly a critique of the speech itself. However, it did occur to me that Dijkstra remained unconvinced that [1] went far enough to extoll the virtues of functional programming versus the supposedly "inelegant" contructs that the von Neuman architecture imposes onto language design. I remain similarly unconvinced that von Neumann architectures were inherently bad, inferior to architectures that are supposed to make FP implementations more efficient, or that the "von Neumann bottleneck" was terrible thing [1] made it out to be.

[1] was given in the late 70's, and today in 2010 von Neumann style programming is still alive and well. Functional programming constructs have certainly made their way into imperative languages, and mostly where they make sense.  While reading [1] (as well as while reading rants from functional programming "purists"), I remained unconvinced of two things.

Firstly, functional programming is neat and nice looking, but in a mathematical way. I get what FP is and why it might seem pretty and neat. I understand why its benefits are good things. What I don't get is, what's so bad with imperative programming - or as I like to see it, practical programming.

Secondly, if imperative languages are starting to incorporate some of the more practical and useful features borrowed from FP (hence, making them more like hybrid imperative/functional languages), why are some people so hell bent on pure functional programming? Sure, there are examples of very nice and simple solutions that make imperative examples look as if cavemen wrote them; but there are a great many practical things that break the purely functional model of programming.

I am not against FP - it provides a nice view of programming; but I can't see how it taken to its logical conclusions offers a better solution than a hybrid language. The future of languages is going to be based on augmenting imperative languages with those features borrowed from FP that produce a significant practical benefit.

In conclusion, I was a bit turned off by [1]; and clearly it's been taken up by people who dream of a purely FP utopia. They're in the great minority, and to be frank, they annoy the crap out of me. I'm attempting this exercise myself, but I'd be interested in seein an example of how one might take a recipe for baking a cake (i.e., an imperative form) and put it into a functional form. Maybe the result will be very clear and concise, but I doubt it - perhaps one can publish a book of recipes in functional form and see how many house wives and grandmothers flock to it. A Better Holmes classic it will not be. I am going to think more about this issue of the von Neumann bottleneck. Sure, [1] paints a pretty ugly picture of it, but I don't think its an obstacle more than just the nature of how a human being might practically implement random access to memory.

'nf
<pre>
References
  [1] <a href=http://www.stanford.edu/class/cs242/readings/backus.pdf>http://www.stanford.edu/class/cs242/readings/backus.pdf</a>
  [2] <a href=http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD692.html>http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD692.html</a>
</pre>
'fi
